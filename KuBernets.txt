1. Triển khai dự án trên k8s và vận hành hệ thống trên k8s

* Bài 1 : K8s là gì ?
Kubernetes là một công cụ giúp thuận lợi trong việc cấu hình tự động hóa triển khai các ứng dụng.

K8s dùng để làm gì ?
Khắc phục vấn đề tự động backup , tự động sửa lỗi , tự động tăng giảm tài nguyên phù hợp với lượng người dùng và quản lý chuyên nghiệp , tự động triển khai dự án

* Bài 2 : Khi nào nên sử dụng k8s ?
	Điều kiện áp dụng giải pháp
	- Hiệu quả , minh bạch , khả năng vận hành , tối ưu chi phí
	
	Dự án phù hợp áp dụng k8s
	- Dự án lớn , dự án chạy đường dài 
	- Dự án có nhu cầu cao về mở rộng 
	- Dự án cần triển khai đa môi trường 
	- Dự án theo mô hình Microservices
	- Dự án cần khả năng tự phục hồi (Self-Healing)

* Bài 3: Triển khai Cluster 
// Trong 1 cụm K8S bao gồm những gì : là 1 cụm Cluster bao gồm các Node và 1 cụm Control Plane
1. Node 
- Có thể có nhiều pod , 
- mỗi pod lưu trữ các containter có thể có nhiều container , pod là đơn vị nhỏ nhất trong cum k8s 
- kubelet là thành phần nhận yêu cầu từ Kube-api-server để thực thi các pod trên node,
- kube-proxy là thành phần network chạy trên mỗi node cho phép các pod giao tiếp với nhau và giao tiếp ra bên ngoài

2. Control Plane 
- cloud-control-manager máy chủ quản lý
- kube-api-server : là một API quy chuẩn chung để giao tiếp ở ngoài vào trong cụm
ví dụ cloud control manager có yêu cầu lấy thông tin pod của node thì kube-api-server sẽ lấy thông tin tương ứng pod của node cần đó
- etcd : là một csdl phân tán dùng để lưu trữ mọi cấu hình của k8s và các trạng tháng của pod , node , các tài nguyên 
- scheduler : trách nhiệm phân phối pod tới các node trong cluster và nó sẽ xem các yếu tố như tài nguyên, ram , CPU , các chính sách , yêu cầu cụ thể khác 
- Controller Manager : Là thành phần quản lý các controller và tiến trình để chịu trách nhiệm giám sát các trạng thái của cluster và thực hiện các hành động sửa chửa tự động nếu cần
(Ví dụ khi dự án của bạn đang chạy trên node 1 mà bị lỗi thì controller manager sẽ tự động giám sát và tạo ra một pod mới để đảm bảo dự án của bạn chạy ổn định)

* Bài 4 K8S Chia thành 2 môi trường chính đó là On-premise và Cloud
Có 2 cách cài là cài đặt thủ công và cài đặt tự động 
- Cài đặt bằng kubeadm là cài đặt thủ công và rành mạch nhất
- Cài đặt tự động bằng kubespray , kops , RKE

* Bài 5 (Triển khai trên môi trường On-premise)
- Điều kiện tối thiểu phải có ít nhất 3 server để triển khai trong đó 1 máy làm Master mặc định là không được triển khai dự án lên đó và 2 node còn lại làm worker có thể triển khai dự án
- Triển khai ít nhât 3 máy chủ ubuntu 1 máy làm Master , 2 máy còn lại làm worker

bước 1 :
	- vào nano /etc/hosts sau đó add 3 IP server của 3 cụm node vào và sau đó đặt tên k8s-master-1 , k8s-master-2 , k8s-master-3 cho từng ip đó và làm như thế với 2 node còn lại
	- vào nano /etc/hostname của 3 server thành k8s-master-1 , k8s-master-2 , k8s-master-3
bước 2 :
	* k8s-master-1 && k8s-master-2 && k8s-master-3 
	- sudo apt update -y && sudo apt upgrade -y
	- adduser devops-k8s 
	- usermod -aG sudo devops-k8s
	- su devops-k8s
	- sudo swapoff -a 
	- cat /etc/fstab
	- sudo sed -i '/swap.img/s/^/#/' /etc/fstab
	- sudo tee /etc/modules-load.d/containerd.conf <<EOF
	overlay
	br_netfilter
	EOF
	- sudo modprobe overlay
	- sudo modprobe br_netfilter
	- sudo tee /etc/sysctl.d/kubernetes.conf <<EOF
	net.bridge.bridge-nf-call-ip6tables = 1
	net.bridge.bridge-nf-call-iptables = 1
	net.ipv4.ip_forward = 1
	EOF
	- sudo sysctl --system
	- sudo apt install -y curl gnupg2 software-properties-common apt-transport-https ca-certificates
	- sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmour -o /etc/apt/trusted.gpg.d/docker.gpg
	- sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
	- sudo apt update -y
	- sudo apt install -y containerd.io
	- containerd config default | sudo tee /etc/containerd/config.toml >/dev/null 2>&1
	- sudo sed -i 's/SystemdCgroup \= false/SystemdCgroup \= true/g' /etc/containerd/config.toml
	- sudo systemctl restart containerd
	- sudo systemctl enable containerd
	- sudo systemctl status containerd
	- sudo mkdir -p /etc/apt/keyrings
	- curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
	- echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list
	- sudo apt update -y
	- sudo apt install -y kubelet kubeadm kubectl
	- sudo apt-mark hold kubelet kubeadm kubectl

bước 3 : 
	Chọn k8s-master-1 làm cụm master 
	- sudo nano /etc/containerd/config.toml -> sandbox_image = "registry.k8s.io/pause:3.9"
	- sudo kubeadm init  
	- mkdir -p $HOME/.kube
	- sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
	- sudo chown $(id -u):$(id -g) $HOME/.kube/config
	( ta sẽ thấy thông tin câu lệnh kubeadm join ip của cụm k8s-master-1:6443 --token h2kmsp. và sau đó - nhớ copy khúc câu lệnh đó bỏ qua 2 cụm worker k8s-master-1 và k8s-master-2)
	- kubectl get nodes
	- kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/calico.yaml
	- kubectl get nodes
	- kubectl label node k8s-master-2 node-role.kubernetes.io/worker=
	- kubectl label node k8s-master-3 node-role.kubernetes.io/worker=
	
	// khiến cụm master cũng có thể đẩy được dự án lên 3 cụm vừa lá master vừa là worker
	- sudo kubeadm reset -f ( chạy trên cả 3 cụm )
	- sudo rm -rf /var/lib/etcd
	- sudo rm -rf /etc/kubernetes/manifests/*
	- kubectl get no
	- clear 
	- sudo kubeadm init --control-plane-endpoint "ip-server-k8s-master-1:6443" --upload-certs
	- mkdir -p $HOME/.kube
	- sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
	- sudo chown $(id -u):$(id -g) $HOME/.kube/config
	- copy câu lệnh và dán sudo kubeadm join ip của k8s-master-1:6443 --token h2kmsp.sau đó - nhớ copy khúc câu lệnh đó bỏ qua 2 cụm worker k8s-master-1 và k8s-master-2
	( Sau khi add xong nhớ quay lại k8s-master-1 để kiểm tra với câu lệnh kubectl get nodes) nhưng với vai trò là --control-plane --certificate-key 
	- kubectl get no
	- kubectl taint nodes k8s-master-1 node-role.kubernetes.io/control-plane:NoSchedule-
	- kubectl taint nodes k8s-master-2 node-role.kubernetes.io/control-plane:NoSchedule-
	- kubectl taint nodes k8s-master-3 node-role.kubernetes.io/control-plane:NoSchedule-
	
	Chọn k8s-master-2 && k8s-master-3 làm cụm worker
	- copy câu lệnh và dán sudo kubeadm join ip của k8s-master-1:6443 --token h2kmsp.sau đó - nhớ copy khúc câu lệnh đó bỏ qua 2 cụm worker k8s-master-1 và k8s-master-2
	- kubectl get nodes
	( Sau khi add xong nhớ quay lại k8s-master-1 để kiểm tra với câu lệnh kubectl get nodes)
	
	// khiến cụm master cũng có thể đẩy được dự án lên 3 cụm vừa lá master vừa là worker
	- sudo kubeadm reset -f ( chạy trên cả 3 cụm )
	- sudo rm -rf /var/lib/etcd
	- sudo rm -rf /etc/kubernetes/manifests/*
	- copy câu lệnh và dán sudo kubeadm join ip của k8s-master-1:6443 --token h2kmsp.sau đó - nhớ copy khúc câu lệnh đó bỏ qua 2 cụm worker k8s-master-1 và k8s-master-2
	( Sau khi add xong nhớ quay lại k8s-master-1 để kiểm tra với câu lệnh kubectl get nodes) nhưng với vai trò là --control-plane --certificate-key 

* bài 6 : Triển khai kubernetes trên nền tảng GCP (GKE)
	- Đăng ký visa và đăng ký tài khoản gg cloud để được 300$ miễn phí 
	- vào 3 thanh sọc -> kubernetes Engine -> Clusters -> Create -> Standard:you manage Your Cluster(Configure)
	- Sau đó sẽ thấy  (Cluster basics) -> đặt tên (Cluster) theo dự án hoặc môi trường -> Zone(asia-northeast1-c) -> target release channel (regular) // đừng vội nhấn create
	  Sang tab (Fleet registration) // chưa cần thiết nên không chọn gì 
	  Chọn Default-pool ( để mặc định ) -> nodes -> image type -> Ubuntu with containerd
					    -> Networking ( để mặc định )
					    -> Security ( để mặc định )
					    -> Metadata -> Kubernetes lables -> ADD KUBERNETS LABEL ( key 1 : env , value : develop )
	  Cluster -> Tất cả đều đều mặc định -> Create
	- Sau khi dựng xong chọn CONNECT -> sau đó enter để xác thực kết nối 
					 - kubectl get node -o wide

* Bài 7 : Mô hình triển khai dự án trên k8s , reaseach kubernetest flow 

* Bài 8 : File yaml Cấu hình trong k8s

	- Ưu điểm file yaml
		# Cú pháp đơn giản
		# Định dạng phong phú 
		# Cấu trúc rõ ràng 
		# Cộng đồng lớn
	
	- Cấu trúc file yaml
		# key là tên thuộc tính
		# value là giá trị tương ứng
➡️ Ví dụ trong Kubernetes: name: my-app

	key: value
 	map:
	    key1: value1
	    key2: value2
	list :
	  - element1
	  - element2
        # This is a comment
	listOfMaps:
	  - key1: value1a
	    key2: value1b
	  - key1: value2a
	    key2: value2b

	// Example 
	containers:
  	  - name: app
            image: nginx
	  - name: sidecar
    	    image: busybox
	env:
  	  - name: DB_HOST
            value: localhost
  	  - name: DB_PORT
	    value: "5432"


- Thành phần chính cấu trúc yaml k8s
	apiVersion: v1 -> Dùng cho: Tài nguyên cơ bản (core resources)
	Ví dụ: Pod, Service, ConfigMap, Secret, Namespace, PersistentVolume, PersistentVolumeClaim,..., ReplicaSet
	
	apiVersion: apps/v1  -> Dùng cho: Quản lý workload (ứng dụng chạy trên cluster)
	Ví dụ: Deployment, StatefulSet, DaemonSet, ReplicaSet
	
	apiVersion: batch/v1 -> Dùng cho: Tác vụ theo lô hoặc định kỳ
	Ví dụ: Job, CronJob
	
	apiVersion: networking.k8s.io/v1 -> Dùng cho: Mạng và ingress
	Ví dụ: Ingress, NetworkPolicy 
	
	apiVersion: policy/v1 -> Dùng cho: Chính sách bảo mật
	Ví dụ: PodDisruptionBudget (giới hạn số Pod bị stop khi cập nhật)
	
	apiVersion: rbac.authorization.k8s.io/v1 -> Dùng cho: Phân quyền truy cập (RBAC)
	Ví dụ: Role, ClusterRole, RoleBinding, ClusterRoleBinding
	
	apiVersion: autoscaling/v1 -> Dùng cho: Tự động scaling (tự tăng/giảm tài nguyên)
	Ví dụ: HorizontalPodAutoscaler (HPA)

	apiVersion: storage.k8s.io/v1 -> Dùng cho: Cấu hình lưu trữ
	Ví dụ: StorageClass, CSIDriver, VolumeAttachment

	✅ kind: Pod
	Ý nghĩa: Là đơn vị nhỏ nhất trong Kubernetes, chứa container hoặc nhiều container chạy chung network.
	Khi dùng: Khi bạn muốn chạy một container (hoặc vài cái gắn liền) đơn lẻ.
	Lưu ý: Không nên deploy trực tiếp Pod trong production — dùng Deployment sẽ tốt hơn.

	✅ kind: Deployment
	Ý nghĩa: Quản lý việc tạo và cập nhật nhiều bản sao (Replica) của một Pod.
	Khi dùng: Khi muốn deploy ứng dụng ổn định, có khả năng tự động cập nhật, rollback.
	Ví dụ: Web app, backend services...

	✅ kind: StatefulSet
	Ý nghĩa: Tương tự Deployment nhưng dành cho ứng dụng có trạng thái, yêu cầu lưu trữ ổn định và tên định danh cố định.

	Khi dùng: Database như MySQL, PostgreSQL, Kafka, Zookeeper...

	Lưu ý: Các Pod sẽ được tạo theo thứ tự, và có volume riêng gắn liền với tên Pod.

	✅ kind: DaemonSet
	Ý nghĩa: Đảm bảo mỗi node đều có 1 bản chạy của Pod.

	Khi dùng: Chạy các agent như log collector (Fluentd, Filebeat), monitoring (Prometheus Node Exporter).
	Đặc biệt: Tự động thêm Pod khi có node mới được thêm vào cluster.

	✅ kind: Service
	Ý nghĩa: Cung cấp endpoint ổn định (DNS/IP ảo) để các Pod khác có thể truy cập.
	Khi dùng: Khi muốn expose Pod ra bên ngoài hoặc kết nối giữa các Pod nội bộ.
	Loại phổ biến: ClusterIP, NodePort, LoadBalancer.

	✅ kind: Ingress
	Ý nghĩa: Cung cấp routing HTTP(S) đến Service theo domain/path.
	Khi dùng: Khi bạn cần truy cập ứng dụng từ bên ngoài qua địa chỉ như myapp.com.
	Yêu cầu: Cần cài Ingress Controller (nghĩ như reverse proxy).

	✅ kind: ConfigMap
	Ý nghĩa: Lưu trữ cấu hình dạng key-value không nhạy cảm.
	Khi dùng: Truyền file config, biến môi trường vào Pod.
	Ví dụ: application.properties, flags...

	✅ kind: Secret
	Ý nghĩa: Tương tự ConfigMap nhưng dùng để lưu thông tin nhạy cảm (đã mã hóa base64).
	Khi dùng: Lưu mật khẩu, token, SSH key...
	An toàn hơn ConfigMap: Vì kube-apiserver xử lý đặc biệt.

	✅ kind: PersistentVolume (PV)
	Ý nghĩa: Tài nguyên lưu trữ được cung cấp bởi admin (file system, cloud disk…).
	Khi dùng: Tạo volume lưu trữ cố định cho Pod.
	
	✅ kind: PersistentVolumeClaim (PVC)
	Ý nghĩa: Lời yêu cầu sử dụng PV của người dùng.

	Khi dùng: Gắn volume vào Pod bằng cách claim (yêu cầu) từ PV có sẵn hoặc tự tạo theo StorageClass
	✅ Metadata, 
	✅ spec
* Bài 9 : NameSpace trong K8S
	* Trong k8s namespace là một cách tổ chức và phân tách các tài nguyên trong một cụm k8s để quả lý tốt hơn , 
	được sử sụng để chia nhỏ tài nguyên của một cụm lớn thành các không gian làm việc logic nhỏ hơn , giúp dễ dàng quản lý và vận hành 
	* vào k8s-master-1 
	- kubectl get pod --namespace default
	- kubectl get ns // dùng để coi số namespace
	- kubectl create ns project-1 (sẽ tạo ra namespace/project-1 created)
	- kubectl delete ns project-1 (sẽ xoá namespace/project-1 deleted)
	- mkdir projects
	- cd projects
	- mkdir project-1
	- cd project-1
	- nano ns.yaml // tạo ra một namespace
		apiVersion: v1
		kind: Namespace
		metadata:
		  name: project-1
	- kubectl apply -f ns.yaml(namespace/project-1 created)
	- kubectl get ns
	- ls
	- kubectl delete -f ns.yaml(namespace/project-1 deleted)
	- kubectl apply -f ns.yaml(namespace/project-1 created)
	- nano resourcequota.yaml // giới hạn tài nguyên cho namespace đó
		apiVersion: v1
		kind: ResourceQuota
		metadata:
		  name: mem-cpu-quota
		  namespace: project-1
		spec:
		  hard:
		    requets.cpu: "2"
		    requets.memory: 4Gi
	- kubectl apply -f resourcequota.yaml
	- ls
			
* Bài 10 : Phương pháp triển khai dự án trên Kubernetes hiệu quả
	- Dựa vào nhu cầu -> Sử dụng công cụ giao diện -> trích xuất file yaml -> Nghiên cứu cú pháp , format , giá trị , template , các tùy chọn khác -> Triển khai tương tự chuẩn format 

* Bài 11 : Công cụ quản lý Kubernetes 
	* K8s management tools ( command app , Desktop app , Website app)
	* K9s là 1 công cụ quản lý k8s trên môi trường command line
	* Công cụ quản lý k8s bằng Desktop App (lens) quản lý bằng giao diện
	* Công cụ quản lý k8s bằng nền tảng web Rancher (được hỗ trợ phân quyền mạnh mẽ)

* Bài 12: Cài đặt Rancher và quản lý K8S
	- Rancher là một công cụ giúp triển khai và quản lý giám sát nhiều cum K8S trên các môi trường khác nhau
	bao gồm cả On-premise và các dịch vụ như AWS , Azure , Google Cloud Plasform 
	- Rancher làm được gì
		* Quản lý nhiều cụm K8S
		* Phân quyền mạnh mẽ ( based RBAC Kubernets)
		* Hõ trợ giám sát cụm Kubernetes
		* Bảo mật tốt
	- Cài đặt Rancher bằng Docker hoặc chạy Rancher lên trực tiếp cụm K8S
		* Tạo một server để install Rancher và add thêm một ổ đĩa khác trong phần edit 
		* tiếng hành mount ổ đĩa 
			- sudo mkfs.ext4 -m 0 /dev/sdb
			- mkdir /data
			- echo "/dev/sdb  /data  ext4  defaults  0  0" | sudo tee -a /etc/fstab
			- mount -a
			- sudo df -h

			// tiến hành tải docker và tải rancher bằng docker-compose
			- apt-update
			- apt install docker && apt install docker-compose
			- mkdir /data/rancher
			- cd /data/rancher
			- nano docker-compose.yml
				version: '3'
				services:
				  rancher-server:
				    image: rancher/rancher:v2.9.2
				    container_name: rancher-server
				    restart: unless-stopped
				    ports:
				      - "80:80"
				      - "443:443"
				    volumes:
				      - /data/rancher/data:/var/lib/rancher
				    privileged: true
			- docker-compose up -d --build
			- docker ps -a
			- vào google truy cập https://ip của server
			- docker logs rancher-server 2>&1 | grep "Bootstrap Password:" // lấy mật khẩu
			- dán passworld vừa lấy được vào trong web Rancher -> Log in with Local User
				* chọn Set a specifsc password to use // dùng để setup passworld mới
				* New Password
				* Confirem New Password
				* Tích chọn By checking the box , you accept the End User -> Saving
			- vào hosts của windows trong system32 với linux thì nano /etc/hosts
				* thêm ip của server-rancher và domain bạn tự đặt
			 	* Dùng domain đã thêm vào hosts rồi vào google sử dụng domain đó nhập username và password
			// kết nối cụm K8S lên rancher để quản lý 
			- trên Dashboard rancher -> chọn Import Existing -> chọn Generic 
                                * Cluster Name (là cụm K8s của mình ví dụ Devopsk8s) -> Create 
				// nếu SSL tự ký thì sử dụng dòng thứ 2 
				* Coppy dòng thứ 2 
				* Vào server k8s-master-1 và paste dòng lệnh đã copy ở trên vào 
				* Vào lại web Rancher sẽ lấy trạng thái pending chuyển thành waiting 
				* chờ một vào phút sau đó nhấn vào Machine Pools sẽ lấy các cụm k8s đã được tạo
				* Ra home sẽ thấy một cụm Devopsk8s nhấn vào và coi thông tin (các Pods , CPU , Memory)
				

* Bài 13: Cài đặt Rancher trên cloud
	 - Chọn Computer Engine -> VM instances -> Create instances
					* Name (đặt là rancher-server) 
					* Region (chọn asia-notheast1(Tokyo)) - Zone ( asia-notheast1-c)
					* Availability polices -> VM provisioning model (chọn Standard)
				-> qua Task Machine configuration 
					* Machine type -> PRESET (es-small(2 vCPU, 1 core , 2GB memory)) // tiết kiện chi phí
				-> qua Task OS and storage -> nhấn CHANGE (có thể thay đổi disk hoặc không)
					* Chọn ADD NEW DISK 
						- Name (đặt disk-mount-data-rancher hoặc tên khác)
						- Disk source type (Blank disk)
						- Size (40GB) -> Save
				-> qua Task Networking 
					* Firewall -> tích chọn Allow HTTP traffic && Allow HTTPS traffic 
				-> CREATE
	- Trên thanh tìm kiếm gõ rancher -> chọn rancher-server -> kép xuống Network interfaces sẽ thấy địa chỉ pulblic IP
	// Tiến hành SSH 
	- sudo -i
	- apt update -y
	- apt install docker.io docker-compose
	- lsblk
	- sudo mkfs.ext4 -m 0 /dev/sdb
	- mkdir /data
	- echo "/dev/sdb  /data  ext4  defaults  0  0" | sudo tee -a /etc/fstab
	- mount -a
	- sudo df -h
	- docker run --name rancher-server -d --restart=unless-stopped -p 80:80 -p 443:443 -v /data/rancher:/var/lib/rancher --privileged rancher/rancher:v2.9.2
	- docker logs  rancher-server  2>&1 | grep "Bootstrap Password:" // lấy password
	- vào google truy cập https://ip của server
	- dán passworld vừa lấy được vào trong web Rancher
				* chọn Set a specific password to use // dùng để setup passworld mới
				* New Password
				* Confirem New Password
				* Tích chọn By checking the box , you accept the End User -> Saving
	- Vào dashboard của Rancher -> ở thanh 3 sọc -> chọn VPC Network -> chọn RESERVE EXTERNAL STATIC IP ADDRESS -> kéo xuống  Attached to (gõ tìm rancher-server)
	- có thể không dùng IP STATIC cũng được 

* Bài 14 : Pod K8S
	- Pod là đơn vị triển khai nhỏ nhất và đơn giãn nhất trong k8s 1 pod sẽ đại diện cho 1 hay nhiều 
	container được nhóm lại với nhau để chia sẻ tài nguyên hay là mạng và mỗi pods sẽ có 1 IP server
	riêng , có thể nói pods là 1 môi trường chia sẻ hoặc là máy chủ ứng dụng 
	// Vào server k8s-master-1
	- cd projects
	- vào google tìm dockerhubs và tìm dockerhubs của chính mình (ví dụ vuduyduc)
	- vào lại server k8s-master-1
	- mkdir frontend
	- cd frontend 
	- nano ns.yaml
		apiVersion: v1
		kind: Namespace
		metadata:
		  name: frontend
	- nano pod.yaml
		apiVersion: v1
		kind: Pod
		metadata:
		  name: frontend
		  namespace: frontend
		spec:
		  containers:
		  - name: frontend
		    image: vuduyduc/frontend
		    ports:
		    - containerPort: 80
	- kubectl apply -f ns.yaml
	- kubectl apply -f pod.yaml
	- kubectl get pod -n frontend // trong đó frontend là namespace trong pod.yaml
	- kubectl exec -it frontend -n frontend -- /bin/bash // dùng để truy cập vào môi trường của namespace đó
	- kubectl delete -f pod.yaml // dùng để xoá pods này đi 
	* hiện tại chúng ta đang có 1/1 pods , chúng ta có thể tăng số lượng lên 2,3,4 để tăng khả năng 
	chịu tải , nhưng chỉ khuyến khích chỉ nên triển khai 1 container trong 1 pods thôi.

* Bài 15 : Deployment với Kubernetes
	* Deployment là 1 đối tượng quản lý pods quản lý về mãng ứng dụng
	* Scale ứng dụng : tăng số lượng pods để đảm bảo tính hoạt động ổn định
	* Tự động khôi phục lỗi : khi một pods bị lỗi sẽ tự tạo lại một pods mới để luôn đảm bảo đủ số lượng
	pods
	// Vào ranger của devopsk8s trên web đã tạo ở bài trước
	* trên thanh header có Only User Namespaces -> chon vào namespaces Frontend đã triển khai bài trước
	* ở Thanh Cluster -> chọn workloads -> trên thanh headers thấy chỗ mũi tên đi lên (import yaml)
	nhấn vào sau đó sẽ thấy Default Namespaces -> chọn frontend -> cancel vì chưa cần thiết
	* bên cạnh nút (import yaml) sẽ thấy nút >_ thì nhấn vào sẽ xuất hiện command line ở dưới giúp chúng
	ta đỡ phải truy cập vào server
		- kubectl get no
	* bên cạnh nút >_ sẽ có nút (Download KubeConfig) , Coppy , tìm kiếm các tài nguyên
	* Trong workloads sẽ có những phàn triển khai các Deployment và Pods
	// ví dụ đầu tiên 
	* Chọn vào Pods -> Create 
		- Namespaces : frontend
		- Name : frontend
		- Container Name : frontend
		- Container image : vuduyduc/frontend
		* Ở phần Networking -> chọn Add Port or Service
			- Name : đặt là tcp
			- Private Container Port : 80
			- Create
	* Chúng ta sẽ tạo được một pods và biết được pods đó được tạo trên server nào
	* bên cạnh Age (phần thời gian đang chạy) có nút 3 chấm
		* Excute Shell (truy cập vào môi trường của container)
		* View Log (xem logs của pod đó)
		* Edit Config (chỉnh sửa config của pods)
		* Edit YAML (File yaml của pods)
		* Clone
		* Download YAML
		* Delete // ở đây chúng ta sẽ xoá ngay lập tức cụm này 
	* Trong workloads -> chọn Deployments -> Chọn create
		- Namespaces : frontend
		- Name : frontend-deployment
		- Replicas : đặt lên 3 (có thể đăt bao nhiêu tuỳ theo dự án)
		- Container Name : frontend
		- Container image : vuduyduc/frontend
		* Ở phần Networking -> chọn Add Port or Service
			- Name : đặt là tcp
			- Private Container Port : 80
			- Create
		* Sau đó qua lại phần Pods có thể nhìn thấy 3 Pods đã được tạo ra (3 pods này cấu hình 
		hệt nhau) - và từng Pods đã được triển khai trên từng server như nhau , ngay cả khi có
		tự xoá pods hoặc pods đó có bị sập thì Schedule vẫn có thể tự tạo lại cái Pods đó 
		* Vào lại phần Deployment vào phần Health -> sẽ thấy xuất hiện Scale thêm bằng cách 
		nhấn dấu + hoặc giảm bằng dấu trừ // tăng giảm số lượng pods cần thiết
		* Sau đó quay trở lại pods thì sẽ thấy một pods mới được tạo ra 
	* Tiến hành Download YAML trong Deployment -> tiếp theo mở file đó lên trong visual code
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  labels:
		    workload.user.cattle.io/workloadselector: apps.deployment-frontend-frontend-deployment
		  name: frontend-deployment
		  namespace: frontend
		spec:
		  replicas: 2 // số lượng pods
		  revisionHistoryLimit: 11 // Lưu lịch sử 
		  selector:
		    matchLabels:
		      workload.user.cattle.io/workloadselector: apps.deployment-frontend-frontend-deployment
		  template:
		    metadata:
		      labels:
		        workload.user.cattle.io/workloadselector: apps.deployment-frontend-frontend-deployment
		      namespace: frontend
		    spec:
		      containers:
		        - image: vuduyduc/frontend
			  imagePullPolicy: Always
		          name: frontend
		          ports:
		            - containerPort: 80
		              name: tcp
		              protocol: TCP
	* Bước tiếp theo copy file YAML vừa được edit xong
	* vào Deployment xoá frontend-deployment cũ đi
	* chọn Import YAML dán phần đã edit vào file YAML nhớ chọn Default Namespace của dự án 
	(ví dụ frontend) -> sau đó import 
	* Sau khi khởi tạo thành công sang Pods sẽ thấy 2 Pods được tạo ra

* Bài 16 : Các commands hay dùng Deployment
	// vào trong server k8s-master-1
	- cd /projects/frontend
	- kubectl get deployments -n frontend ( // trong đó frontend là namespaces)
		sẽ xuất thiện thông tin NAME (ví dụ frontend-deployment)
	- kubectl get rs -n frontend
	- kubectl edit deployment/frontend-deployment
	- kubectl rollout status deployment/frontend-deployment -n frontend
	- kubectl scale deployment/frontend-deployment --replicas=4 -n frontend 
						(trong đó replicas tăng số lương pods)
	* Sau đó vào trong Deployment ở Workloads ở web Rancher để xem số lượng pods đã được tạo ra  

	// một số câu lệnh deployment thường dùng (ví dụ ten-deployment : deployment/frontend-deployment)
						  (namesplace là frontend)
	# kubectl scale deployment <ten-deployment> --replicas=<so-replicas> // Cập nhật trực tiếp số lượng replicas
	# kubectl describe deployment -n <namespace> // Xem chi tiết cụ thể về một Deployment
	# kubectl get deployment <ten-deployment> -o yaml // Xem cấu hình YAML của một Deployment
	# kubectl set image deployment/<ten-deployment> <ten-container>=<ten-image>:<tag-moi> // Cập nhật Deployment bằng cách thay đổi hình ảnh container
	# kubectl rollout undo deployment <ten-deployment> // Rollback Deployment về phiên bản trước
	# kubectl rollout history deployment <ten-deployment> // Kiểm tra lịch sử các phiên bản của Deployment
	# kubectl get pods -l app=<ten-deployment> -n <namespace> // Liệt kê các Pod được tạo bởi một Deployment cụ thể
	# kubectl set env deployment/<ten-deployment> <key>=<value> // Cập nhật biến môi trường cho các container trong Deployment

* Bài 17 : Các chiến lược triển khai Deployment k8s
	* Có 2 chiến lượng triển khai
	* Rolling Update (cập nhật dần các Pods) 
		- ví dụ chúng ta có 2 pods và triển khai version mới chúng ta thiết lập rằng cứ có 1 pods
		mới lên thì xoá một pods cũ đi vậy chúng ta sẽ có 1 pods version cũ và 1 pods version mới
		vẫn có thể đảm bảo dự án hoạt động được .
	* Recreate (tạo mới hoàn toàn các Pods)
		- Xoá toàn bộ pods đi và khởi tạo lại toàn bộ pods mới 
	* Thông thường hay sử dụng chiến lượt đầu tiên
	* Vào web Rancher > Deployment xoá đi deployment cũ 
	* Vào trong phần visual edit lại file YAML
		// Đây là file YAML của Recreate - chiến lượt thứ 2 
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  labels:
		    app: frontend-deployment // chỉnh sửa ngắn gọn ở chỗ này
		  name: frontend-deployment
		  namespace: frontend
		spec:
		  replicas: 4 // số lượng pods
		  strategy:
		    type: Recreate
		  revisionHistoryLimit: 11 // Lưu lịch sử 
		  selector:
		    matchLabels:
		      app: frontend-deployment // chỉnh sửa ngắn gọn ở chỗ này
		  template:
		    metadata:
		      labels:
		        app: frontend-deployment // chỉnh sửa ngắn gọn ở chỗ này
		      namespace: frontend
		    spec:
		      containers:
		        - image: nginx 
			  imagePullPolicy: Always
		          name: frontend
		          ports:
		            - containerPort: 80
		              name: tcp
		              protocol: TCP
	* tiến hành apply lên rancher ở phần Deployment nhấn chọn Import YAML và paste vào -> Default 
	Namespace vẫn chọn là Frontend -> Import  
	* Vào trong Pods ở rancher để kiểm tra số lượng pods đã được tạo 
	* Vào Edit Config (ở dấu 3 chấm) ở frontend-deployment trong Deployment
		- Thay Container Imge thành vuduyduc/frontend -> Save
	* Vào lại Pods -> sẽ thấy Pods cũ sẽ hoàn toàn bị xoá đi và thay bằng Pods mới 

	// tiến hành triển khai chiến lược Rolling Update
	* Đầu tiên phải xoá đi phần frontend-deployment 
	* Quay lại visual code để Edit file YAML
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  labels:
		    app: frontend-deployment
		  name: frontend-deployment
		  namespace: frontend
		spec:
		  replicas: 2
		  strategy:
		    rollingUpdate:
		      maxSurge: 1 #25%
		      maxUnavailable: 1 #25%
		    type: RollingUpdate
		  revisionHistoryLimit: 11
		  selector:
		    matchLabels:
		      app: frontend-deployment
		  template:
		    metadata:
		      labels:
		        app: frontend-deployment
		      namespace: frontend
		    spec:
		      containers:
		        - image: vuduyduc/frontend
		          imagePullPolicy: Always
		          name: frontend
		          ports:
		            - containerPort: 80
		              name: tcp
		              protocol: TCP
	* tiến hành apply lên rancher ở phần Deployment nhấn chọn Import YAML và paste file YAML đã edit 
	trong visual code vào -> Default Namespace vẫn chọn là Frontend -> Import  
	* Vào trong Pods ở rancher để kiểm tra số lượng pods đã được tạo 

* Bài 18 : Các loại Service trong K8S
	* Service trong K8S là một đối tượng dùng để định nghĩa cách tiếp cận các pods thường là 1 nhóm pods hay chính xác là triển khai các pods qua deployment trong cụm k8s
	* Service Type : có 4 loại 
		# Cluster IP : tạo ra một địa chỉ IP chỉ có thể truy cập được ở trong cụm có thể giao tiếp được với nhau , nếu muốn giao tiếp ra bên ngoài thì cần phải đi qua ingress
		# NodePort : Service này sẽ trực tiếp mở 1 port truy cập từ bên ứng dụng ra bên ngoài , tức là chúng ta có thể truy cập trực tiếp vào pods mà không cần phải đi qua bất cứ cổng nào nữa.
		# LoadBalancer : Dành cho clound Provider , sẽ điều phối lưu lượng tới các service tương ứng 
		# ExternalName : sẽ liên kết với 1 tên miền ở bên ngoài (domain)
	* Cluster IP và LoadBalancer là 2 loại service giúp chuyển khai dự án chuyên nghiệp và thực tế với Cluster IP sẽ được áp dụng trên môi trường On-premise và LoadBalancer sẽ áp dụng cho môi trường cloud

* Bài 19 : NodePort // có thể truy cập trực tiếp từ bên ngoài vào 
	* Chỉ cho phép sử dụng các port từ 300000 - 32767
	* vào trong devopsk8s
	* Trong phần giao diện của Ranchers -> phần Service Discovery -> nhấn chọn vào service
		- nhấn chọn Create -> nhấn chọn vào NodePort -> đặt Name là frontend-service && Port Name để là tcp && Listening Port đặt là 80 && Target Port là 80 && Node Port đặt ví dụ 32080
		- Tiếp theo nhìn kỹ sẽ thấy Selectors -> để key là app && Value là frontend-deployment (coi lại file YAML đã cấu hình trong phần Rolling Update ) -> Create
		- Sau khi tạo xong sẽ thấy frontend-service đã được tạo với port là 32080 ở đây chúng ta có thể dùng IP Server của k8s-master-2 cộng với port 32080 để truy cập
		- bật tag google mới sau đó điền IP của server k8s-master-1 vào sau đó thêm port 32080 ở phía sau
		
* Bài 20 : NodePort K8S Cloud	
	- nhấn vào SSH của cloud đã tạo từ lúc trước để truy cập vào Terminal
	- mkdir devops
	- cd devops 
	- nano frontend.yaml
		apiVersion: apps/v1
		kind: Deployment
		metadata:
		  name: frontend-deployment
		  namespace: frontend
		spec:
		  selector:
		    matchLables:
		      app: frontend
		  replicas:1
		  template:
		    metadata:
		      labels:
			app: frontend
		    spec:
		      containers:
			- name: frontend
			  image: vuduyduc/frontend
			  ports:
			    - containers: 80
		apiVersion: v1
		kind: Service
		metadata:
		  name: frontend-service
		  namespace: frontend
		spec:
		  type: NodePort
		  selector:
		    app: frontend
		  ports:
		    - protocol: TCP
		      port: 80
		      targetPort: 80
		      nodePort: 32080
	- kubectl create ns frontend // tạo namespace cho frontend
	- kubectl apply -f frontend.yaml // áp dụng toàn bộ cấu hình cho file Yaml
	- kubectl get all -n frontend // lấy toàn bộ thông tin cấu hình 
	- kubectl get no -o wide
	* Vào thanh 3 sọc -> Hover vào VPC Network -> Chọn phân Firewall -> tiến hành Create FIREWAKK RULE
	-> kéo xuống Name và điền vào ô Input đó là (allow-port:32080) 
	-> kéo xuống Targets -> chọn vào All instances in the network
	-> kéo xuống source IPv4 rangers -> điền vào 0.0.0.0/0
	-> kéo xuống Specified protocols and ports
		- Chọn TCP và để port là 32080
	-> CREATE
	// vào lại Command Line của Cloud 
	- curl đến IP của 1 server EXTERNAL-IP:32080 (ví dụ 34.86.21.171:32080)
	* mở tag google mới dán 34.86.21.171:32080 sẽ thấy giao diện của trang frontend

* Bài 21 : ClusterIP // không thể truy cập trực tiếp từ bên ngoài vào
	// Khởi tạo Cluster IP 
	* Trong Service Discovery (của devopsk8s) -> chọn Services -> Chọn Create ->  Chọn ClusterIP -> đặt tên Cho Name (frontend1-service) && PortName đặt là tcp && listerning Port là 80 && TargetPort cũng là 80
	* Xuống task Selectors ở bên cạnh -> key là app && Value là frontend-deployment -> CREATE
	* Sau khi tạo xong ở mục target sẽ có một chỗ để link nhấn vào sẽ ra trang web

* Bài 22 : Ingress Kubernetes
	* Ingress Kubernetes là một tài nguyên dùng để quản lý cách thức truy cập từ bên ngoài vào các service bên trong cụm K8S giúp định hướng lưu lượng truy cập HTTP và HTTPS tới các service nội bộ
	* Mô hình đi từ Client -> đến loadbalancer -> đén ingress -> dựa theo hướng dẫn đến các service chính xác và từ service đến Pod tương ứng
	* Ingress nginx && Kong Gateway && HAProxy 3 loại hay sử dụng để triển khai trên ingress trên on-premise 
	* Helm là một loại công cụ quản lý các tài nguyên được cài đặt bằng helm
	* Loadbalencer làm nhiệm vụ cân bằng tải các traffic của NodePort trong K8S đi ra bên ngoài Client

	// vào lại server k8s-master-1 - cài đặt Helm
	- cd && sudo -i
	- wget https://get.helm.sh/helm-v3.16.2-linux-amd64.tar.gz // wget tới đường link để tải xuống 
	- tar xvf helm-v3.16.2-linux-amd64.tar.gz // tar xvf để giải nén 
	- sudo mv linux-amd64/helm /usr/bin/

	// add Chart của Ingress Nginx Controller 
	- helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
	- helm repo update
	- helm search repo nginx
	- helm pull ingress-nginx/ingress-nginx
	- tar -xzf ingress-nginx-4.11.3.tgz // tar -xzf cũng dùng để giải nén 
	- nano ingress-nginx/values.yaml
	>> Sửa type: LoadBalancer => type: NodePort // vì đang triển khai trên On-premise nên sử dụng NodePort
	>> Sửa nodePort http: "" => http: "30080"
	>> Sửa nodePort https: "" => https: "30443"
	- cp -rf ingress-nginx /home/dev
	- su dev
	// mỗi tài nguyên mỗi dự án mỗi môi trường đều tạo ra 1 namespace riêng
	- kubectl create ns ingress-nginx 
	- helm -n ingress-nginx install ingress-nginx -f ingress-nginx/values.yaml ingress-nginx
	- helm version
	- kubectl get all -n ingress-nginx

	// Tạo thêm 1 server mới để triển khai Ingress Nginx 
	- SSH vào server của Ingress Nginx vừa tạo 
	- apt install net-tools -y 
	- apt install nginx -y 
	- nano /etc/nginx/sites-available/default
		đổi listern 80 -> sang port khác (ví dụ : 9999)
	- nano /etc/nginx/conf.d/devops-kubernets.vn.conf
			upstream my_servers {
			    server 192.168.1.111:30080; // k8s-master-1
			    server 192.168.1.112:30080; // k8s-master-2
			    server 192.168.1.113:30080; // k8s-master-3
			}
			
			server {
			    listen 80;
			
			    location / {
			        proxy_pass http://my_servers;
			        proxy_redirect off;
			        proxy_set_header Host $host;
			        proxy_set_header X-Real-IP $remote_addr;
			        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			        proxy_set_header X-Forwarded-Proto $scheme;
			    }
			}
	- nginx -s reload 
	- systemctl restart nginx 

	// trên web Rancher-server trong devopsk8s tạo Ingress trên Rancher 
	* Chọn Servivce Discovery -> chọn Ingress -> Chọn Import YAML
			apiVersion: networking.k8s.io/v1
			kind: Ingress
			metadata:
			  name: frontend-ingress
			  namespace: frontend
			spec:
			  ingressClassName: nginx
			  rules:
			    - host: frontend-onpre.devopsk8s.vn
			      http:
			        paths:
			          - backend:
			              service:
			                name: frontend1-service
			                port:
			                  number: 80
			            path: /
			            pathType: Prefix
	* Import 
	* Muốn biết chính xác tài nguyên Ingress này đã trỏ đúng service chưa thì chọn vào phần này frontend1-service nếu nó di chuyển sang Pods và ở đó có các pods thì bạn đã triển khai đúng 
	* Vào system32 để add hosts và IP của server Nginx Ingress vào
		ví dụ (192.168.1.110 frontend-onpre.devopsk8s.vn)
	* Truy cập bằng domain frontend-onpre.devopsk8s.vn 

* Bài 22 : Triển khai Ingress on Cloud GCP
	// Tiến hành vào lại Cloud trên GCP và SSH vào bên trong 
	- kubectl get all -n frontend 
	- kubectl delete -f frontend.yaml
	- clear

	// ở trên On-premise thì sử dụng NodePort còn trên cloud thì sử dụng LoadBalancer 
	// tiến hành cài Helm trên Clound
	- wget https://get.helm.sh/helm-v3.16.2-linux-amd64.tar.gz
	- tar xvf helm-v3.16.2-linux-amd64.tar.gz
	- sudo mv linux-amd64/helm /usr/bin/
	- helm version

	// Ingress Controller
	- helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
	- helm repo update
	- helm pull ingress-nginx/ingress-nginx
	- tar -xzf ingress-nginx-4.11.3.tgz
	- kubectl create ns ingress-nginx
	- helm -n ingress-nginx install ingress-nginx -f ingress-nginx/values.yaml ingress-nginx
	- nano frontend-service-dp-sv-ig.yaml
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  name: frontend-deployment
			  namespace: frontend
			spec:
			  selector:
			    matchLables:
			      app: frontend
			  replicas:1
			  template:
			    metadata:
			      labels:
				app: frontend
			    spec:
			      containers:
				- name: frontend
				  image: vuduyduc/frontend
				  ports:
				    - containers: 80
			
			apiVersion: v1
			kind: Service
			metadata:
			  name: frontend-service
			  namespace: frontend
			spec:
			  type: ClusterIP
			  selector:
			    app: frontend
			  ports:
			    - protocol: TCP
			      port: 80
			      targetPort: 80

			apiVersion: networking.k8s.io/v1
			kind: Ingress
			metadata:
			  name: frontend-ingress
			  namespace: frontend
			  annotations:
			    kubernetes.io/ingress.class: *nginx*
			spec:
			  rules:
			    - host: frontend-cloud.devopsk8s.vn
			      http:
			        paths:
				    path: /
			            pathType: Prefix
			            backend:
			              service:
			                name: frontend-service
			                port:
			                  number: 80
	- kubectl apply -f frontend-dp-sv-ig.yaml
	// nếu không có domain thì chỉ cần add host vào system32 
	- kubectl get all -n frontend
	- kubectl get ingress -n frontend // sẽ thấy địa chỉ Address và domain tự tạo tiến hành copy Address bỏ vào hosts System32
